<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Pixel Bonfire - Digital Art Installation</title>
    <link href="https://gs.jurieo.com/gemini/fonts-googleapis/css2?family=JetBrains+Mono:wght@400;700&display=swap" rel="stylesheet">
    <style>
        :root { 
            --bg: #000000; 
            --panel-bg: rgba(18, 18, 20, 0.45);
            --text-main: #f5f5f7;
            --text-secondary: #86868b;
            --accent: #ffffff;
            --danger: #ff3b30;
            --border-color: rgba(255, 255, 255, 0.12);
            --panel-width: 320px;
            --control-bg: rgba(255, 255, 255, 0.08);
            --toggle-bg: rgba(255, 255, 255, 0.15);
        }

        * { box-sizing: border-box; }

        body {
            background-color: var(--bg); 
            color: var(--text-main);
            font-family: 'JetBrains Mono', monospace;
            margin: 0; 
            display: flex; 
            height: 100vh; 
            overflow: hidden; 
            touch-action: none;
        }

        /* 桌面端隐藏拖拽区域 */
        #drag-bar {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 30px;
            z-index: 9999;
            -webkit-app-region: drag;
        }

        /* 画布 100% 沉浸模式 */
        #main-view {
            width: 100vw;
            height: 100vh;
            display: flex; 
            align-items: center; 
            justify-content: center;
            background: var(--bg); 
            overflow: hidden; 
            position: absolute;
            top: 0; left: 0;
            perspective: 2000px; 
            z-index: 1;
        }

        /* 硬件加速色相流转过渡层 */
        canvas { 
            image-rendering: pixelated; 
            cursor: crosshair; 
            background: #000; 
            border-radius: 4px; 
            box-shadow: 0 0 80px rgba(0,0,0,0.8);
            transition: filter 0.1s linear; 
        }

        /* 独立唤出按钮 */
        #ui-toggle-btn {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 36px;
            height: 36px;
            background: var(--panel-bg);
            border: 1px solid var(--border-color);
            border-radius: 10px;
            color: var(--text-secondary);
            font-size: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 10000;
            backdrop-filter: blur(25px);
            -webkit-backdrop-filter: blur(25px);
            transition: all 0.3s ease;
            user-select: none;
            -webkit-app-region: no-drag;
        }

        #ui-toggle-btn:hover {
            color: var(--accent);
            background: var(--toggle-bg);
            transform: scale(1.05);
        }

        /* 悬浮毛玻璃控制舱 */
        #ui-panel {
            position: absolute;
            top: 68px; 
            right: 20px;
            width: var(--panel-width);
            max-height: calc(100vh - 88px);
            background: var(--panel-bg);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 16px;
            display: flex;
            flex-direction: column;
            backdrop-filter: blur(25px);
            -webkit-backdrop-filter: blur(25px);
            z-index: 10000;
            box-shadow: 0 20px 40px rgba(0,0,0,0.5);
            transition: opacity 0.4s ease, transform 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            -webkit-app-region: no-drag;
        }

        /* 沉浸式手动隐藏 UI 样式 */
        body.ui-hidden #ui-panel {
            opacity: 0;
            pointer-events: none;
            transform: translateX(120%);
        }

        /* Flexbox 滚动视窗核心修复 */
        .panel-header {
            flex-shrink: 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
            padding-bottom: 12px;
            border-bottom: 1px solid var(--border-color);
        }

        .panel-scroll-area {
            flex: 1;
            overflow-y: auto;
            padding-right: 6px;
            margin-right: -6px; 
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .panel-scroll-area::-webkit-scrollbar { width: 4px; background: transparent; }
        .panel-scroll-area::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.2); border-radius: 10px; }

        .panel-footer {
            flex-shrink: 0;
            display: flex; 
            flex-direction: column; 
            gap: 8px; 
            margin-top: 12px;
            padding-top: 12px;
            border-top: 1px dashed var(--border-color);
        }

        h3 { margin: 0; font-size: 14px; font-weight: 700; letter-spacing: 1px; color: var(--accent); }

        .header-actions { display: flex; gap: 8px; }

        .win-btn {
            width: 24px; height: 24px;
            display: flex; align-items: center; justify-content: center;
            border-radius: 6px; border: none; cursor: pointer;
            background: var(--control-bg); color: var(--text-main);
            transition: all 0.2s; font-size: 10px; font-family: inherit;
        }
        .btn-close:hover { background: var(--danger); color: white; }
        .win-btn:hover { background: var(--toggle-bg); }

        /* 折叠面板样式重构 */
        details {
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            overflow: hidden;
            flex-shrink: 0; 
        }
        summary {
            padding: 12px;
            font-size: 11px;
            font-weight: 700;
            cursor: pointer;
            user-select: none;
            text-transform: uppercase;
            letter-spacing: 1px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: rgba(255,255,255,0.02);
            transition: background 0.2s;
        }
        summary:hover { background: rgba(255,255,255,0.06); }
        summary::-webkit-details-marker { display: none; }
        summary::after { content: '+'; color: var(--text-secondary); font-size: 14px; }
        details[open] summary::after { content: '−'; }
        details[open] summary { border-bottom: 1px solid var(--border-color); }
        
        .details-content {
            padding: 12px;
            display: flex;
            flex-direction: column;
            gap: 12px;
            animation: slideDown 0.3s ease-out;
        }

        @keyframes slideDown {
            from { opacity: 0; transform: translateY(-4px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .control-group { display: flex; flex-direction: column; gap: 8px; }
        label { font-size: 10px; font-weight: 400; color: var(--text-secondary); text-transform: uppercase; }
        
        .val-input {
            float: right; background: transparent; border: none;
            color: var(--text-secondary); font-size: 10px; font-weight: 700;
            text-align: right; width: 45px; outline: none; padding: 0; font-family: inherit;
        }

        #canvas-wrapper { 
            position: relative; 
            line-height: 0; 
            transition: transform 0.6s cubic-bezier(0.4, 0, 0.2, 1);
            transform-style: preserve-3d;
        }
        
        #canvas-wrapper.isometric { transform: rotateX(15deg); }

        .switch { position: relative; display: inline-block; width: 32px; height: 16px; }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: var(--control-bg); transition: .4s; border-radius: 16px; border: 1px solid var(--border-color); }
        .slider:before { position: absolute; content: ""; height: 10px; width: 10px; left: 2px; bottom: 2px; background-color: var(--text-secondary); transition: .4s; border-radius: 50%; }
        input:checked + .slider { background-color: var(--accent); }
        input:checked + .slider:before { transform: translateX(16px); background-color: var(--bg); }

        button.action-btn {
            background: var(--control-bg); color: var(--text-main); border: 1px solid var(--border-color);
            padding: 10px; border-radius: 6px; font-size: 11px; font-weight: 700; cursor: pointer; transition: all 0.2s; font-family: inherit;
        }
        button.action-btn:hover { background: var(--toggle-bg); border-color: var(--text-secondary); }
        
        select {
            background: var(--control-bg); color: var(--text-main); font-family: inherit;
            border: 1px solid var(--border-color); padding: 6px 8px; border-radius: 6px; font-size: 11px;
            outline: none; appearance: none;
            background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='grey' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpolyline points='6 9 12 15 18 9'%3E%3C/polyline%3E%3C/svg%3E");
            background-repeat: no-repeat; background-position: right 8px center; background-size: 12px;
            padding-right: 28px;
        }
        select option { background-color: #121214; color: #f5f5f7; }

        input[type="text"].custom-chars { background: var(--control-bg); color: var(--text-main); border: 1px solid var(--border-color); padding: 6px 8px; border-radius: 6px; font-size: 11px; outline: none; font-family: inherit; }
        input[type="color"] { -webkit-appearance: none; border: none; width: 100%; height: 20px; cursor: pointer; background: none; padding: 0; border-radius: 4px; }
        input[type="color"]::-webkit-color-swatch { border: 1px solid var(--border-color); border-radius: 4px; }
        input[type="range"] { -webkit-appearance: none; width: 100%; height: 2px; background: var(--control-bg); border-radius: 2px; accent-color: var(--accent); }

        .toggle-row { display: flex; justify-content: space-between; align-items: center; }

        /* 极简赛博状态栏 CSS */
        #cyber-status {
            font-family: 'JetBrains Mono', monospace;
            font-size: 10px;
            color: var(--text-secondary);
            line-height: 1.6;
            opacity: 0.85;
            text-shadow: 0 0 6px rgba(134, 134, 139, 0.3);
            user-select: none;
        }
        .blink { animation: blinker 1s step-end infinite; }
        @keyframes blinker { 50% { opacity: 0; } }
    </style>
</head>
<body>

    <div id="drag-bar"></div>

    <div id="main-view">
        <div id="canvas-wrapper">
            <canvas id="fireCanvas"></canvas>
        </div>
    </div>

    <div id="ui-toggle-btn" title="Toggle UI [H]">≡</div>

    <div id="ui-panel">
        <div class="panel-header">
            <h3>BONFIRE_OS</h3>
            <div class="header-actions">
                <button class="win-btn" id="btn-fs" title="Fullscreen">⤢</button>
                <button class="win-btn btn-close" id="btn-close" title="Exit">✕</button>
            </div>
        </div>

        <div class="panel-scroll-area">
            <details open>
                <summary>[ 视觉渲染 / Rendering ]</summary>
                <div class="details-content">
                    <div class="control-group toggle-row">
                        <label>3D 模式 / 3D Mode</label>
                        <label class="switch">
                            <input type="checkbox" id="toggle3DSwitch">
                            <span class="slider"></span>
                        </label>
                    </div>
                    
                    <div id="group3D" style="display:none; flex-direction: column; gap: 12px;">
                        <div class="control-group">
                            <label>混合模式 / Blend Mode</label>
                            <select id="blendMode">
                                <option value="source-over">正常 / Source-Over</option>
                                <option value="lighter">光学叠加 / Lighter</option>
                            </select>
                        </div>
                        <div class="control-group">
                            <label>等高线 / Contours</label>
                            <select id="contourStyle">
                                <option value="none">无 / None</option>
                                <option value="horizontal">横向扫描 / Horizontal</option>
                                <option value="solid" selected>实线网格 / Solid Grid</option>
                                <option value="dashed">虚线网格 / Dashed Grid</option>
                            </select>
                        </div>

                        <div class="control-group toggle-row">
                            <label>色相流转 / Hue Shift</label>
                            <label class="switch"><input type="checkbox" id="toggleHueShift" checked><span class="slider"></span></label>
                        </div>
                        <div class="control-group toggle-row">
                            <label>色差分离 / RGB Split</label>
                            <label class="switch"><input type="checkbox" id="toggleRGBSplit" checked><span class="slider"></span></label>
                        </div>
                        <div class="control-group toggle-row">
                            <label>偶发故障 / Signal Glitch</label>
                            <label class="switch"><input type="checkbox" id="toggleGlitch" checked><span class="slider"></span></label>
                        </div>
                        <div class="control-group toggle-row">
                            <label>深空浮尘 / Void Dust</label>
                            <label class="switch"><input type="checkbox" id="toggleDust" checked><span class="slider"></span></label>
                        </div>

                        <div class="control-group toggle-row">
                            <label>自动旋转 / Auto Rotate</label>
                            <label class="switch">
                                <input type="checkbox" id="toggleAutoRot">
                                <span class="slider"></span>
                            </label>
                        </div>
                        <div class="control-group">
                            <label>手动旋转 / Rotation <input type="number" id="val-rot" class="val-input" readonly></label>
                            <input type="range" id="camRotSlider" min="0" max="360" value="0">
                        </div>
                        <div class="control-group toggle-row">
                            <label>游离余烬 / Embers</label>
                            <label class="switch">
                                <input type="checkbox" id="toggleEmbers" checked>
                                <span class="slider"></span>
                            </label>
                        </div>
                        <div class="control-group toggle-row">
                            <label>景深迷雾 / Depth Fog</label>
                            <label class="switch">
                                <input type="checkbox" id="toggleFog" checked>
                                <span class="slider"></span>
                            </label>
                        </div>
                    </div>
                </div>
            </details>

            <details>
                <summary>[ 形态引擎 / Physics ]</summary>
                <div class="details-content">
                    <div class="control-group">
                        <label>火焰形态 / Form [R]</label>
                        <select id="flameShape">
                            <option value="classic">经典 / Classic</option>
                            <option value="campfire">篝火 / Campfire</option>
                            <option value="torch">火炬 / Torch</option>
                            <option value="inferno">烈焰 / Inferno</option>
                            <option value="ember">余烬 / Ember</option>
                            <option value="plasma">等离子 / Plasma</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <label>画布宽度 / Width <input type="number" id="val-width" class="val-input" title="Max: 1000"></label>
                        <input type="range" id="canvasWidth" min="200" max="1000" value="400">
                    </div>
                    <div class="control-group">
                        <label>画布高度 / Height <input type="number" id="val-height" class="val-input" title="Max: 1000"></label>
                        <input type="range" id="canvasHeight" min="200" max="1000" value="500">
                    </div>
                    <div class="control-group">
                        <label>字符集 / Charset</label>
                        <select id="charSet">
                            <option value="ascii">经典 / ASCII</option>
                            <option value="binary">二进制 / Binary</option>
                            <option value="blocks">方块 / Blocks</option>
                            <option value="braille">盲文 / Braille</option>
                            <option value="dots">点阵 / Dots</option>
                            <option value="japanese">日文 / Kanji</option>
                            <option value="matrix">矩阵 / Matrix</option>
                            <option value="customChar">自定义 / Custom</option>
                        </select>
                    </div>
                    <div class="control-group" id="customCharGroup" style="display:none">
                        <label>输入字符 / Input String</label>
                        <input type="text" id="customInput" class="custom-chars" value="@#$*!">
                    </div>
                    <div class="control-group">
                        <label>字号 / Font Size <input type="number" id="val-font" class="val-input" title="Max: 24"></label>
                        <input type="range" id="fontSize" min="6" max="24" value="12">
                    </div>
                    <div class="control-group">
                        <label>缩放 / Scale <input type="number" id="val-scale" class="val-input" step="0.1" title="Max: 2.0"></label>
                        <input type="range" id="viewScale" min="0.5" max="2.0" step="0.1" value="1.0">
                    </div>
                    <div class="control-group">
                        <label>燃烧速度 / Speed <input type="number" id="val-speed" class="val-input" step="0.1" title="Max: 3.0"></label>
                        <input type="range" id="fireSpeed" min="0.2" max="3.0" step="0.1" value="1.0">
                    </div>
                </div>
            </details>

            <details>
                <summary>[ 色彩与环境 / Environment ]</summary>
                <div class="details-content">
                    <div class="control-group">
                        <label>预设 / Presets</label>
                        <select id="colorPresets">
                            <option value="custom">自定义 / Custom</option>
                            <option value="classic">经典 / Classic</option>
                            <option value="soul">灵魂 / Soul</option>
                            <option value="forest">森 / Forest</option>
                            <option value="cyber">赛博 / Cyber</option>
                            <option value="toxic">剧毒 / Toxic</option>
                            <option value="void">虚空 / Void</option>
                            <option value="sunset">落日 / Sunset</option>
                            <option value="ocean">深海 / Ocean</option>
                            <option value="gold">黄金 / Gold</option>
                            <option value="sakura">樱花 / Sakura</option>
                        </select>
                    </div>
                    <div class="control-group"><label>顶部 / Top</label><input type="color" id="colorTop" value="#ff2200"></div>
                    <div class="control-group"><label>中部 / Mid</label><input type="color" id="colorMid" value="#ff8800"></div>
                    <div class="control-group"><label>底部 / Bottom</label><input type="color" id="colorBottom" value="#ffffff"></div>
                    <button class="action-btn" onclick="randomizeFireColors()">随机配色 / Shuffle Colors [C]</button>
                    
                    <div class="control-group">
                        <label>整体亮度 / Brightness <input type="number" id="val-brightness" class="val-input" step="0.1" title="Max: 3.0"></label>
                        <input type="range" id="camBrightness" min="0.1" max="3.0" step="0.1" value="1.0">
                    </div>
                    <div class="control-group toggle-row">
                        <label>复古监视器 / CRT Filter</label>
                        <label class="switch">
                            <input type="checkbox" id="toggleCRT" checked>
                            <span class="slider"></span>
                        </label>
                    </div>
                    <div class="control-group toggle-row">
                        <label>环境降水 / Rain Mode</label>
                        <button class="action-btn" id="toggleRain" style="padding: 4px 8px;">OFF</button>
                    </div>
                </div>
            </details>
        </div>

        <div class="panel-footer">
            <div id="cyber-status">
                > SYS.KERNEL: ONLINE<br>
                > RENDER_ENGINE: ACTIVE <span class="blink">_</span>
            </div>
        </div>
    </div>

    <script>
        let win;
        try {
            win = nw.Window.get();
            document.getElementById('btn-close').onclick = () => win.close();
            document.getElementById('btn-fs').onclick = () => win.toggleFullscreen();
        } catch(e) {}

        const canvas = document.getElementById('fireCanvas'), wrapper = document.getElementById('canvas-wrapper'), ctx = canvas.getContext('2d', { alpha: false });
        
        document.getElementById('ui-toggle-btn').addEventListener('click', () => {
            document.body.classList.toggle('ui-hidden');
        });

        const shapePresets = {
            classic: { h: 15, c: 1.2 },
            campfire: { h: 12, c: 1.8 },
            torch: { h: 22, c: 0.5 },
            inferno: { h: 25, c: 2.0 },
            ember: { h: 6, c: 0.8 },
            plasma: { h: 18, c: 0.2 }
        };

        const flameShapeSelect = document.getElementById('flameShape');
        flameShapeSelect.addEventListener('change', (e) => {
            const p = shapePresets[e.target.value];
            if(p) { flameHeight = p.h; chaosLevel = p.c; wind = 0; }
        });

        window.addEventListener('keydown', (e) => {
            if (e.target.tagName === 'INPUT' && e.target.type === 'text') return;
            const key = e.key.toLowerCase();
            if (key === 'h') {
                document.body.classList.toggle('ui-hidden');
            } else if (key === 'r') {
                const keys = Object.keys(shapePresets);
                const randomKey = keys[Math.floor(Math.random() * keys.length)];
                flameShapeSelect.value = randomKey;
                flameShapeSelect.dispatchEvent(new Event('change'));
            } else if (key === 'c') {
                randomizeFireColors();
            }
        });

        const fontSizeInput = document.getElementById('fontSize'), viewScaleInput = document.getElementById('viewScale'), speedInput = document.getElementById('fireSpeed'), widthInput = document.getElementById('canvasWidth'), heightInput = document.getElementById('canvasHeight'), charSetSelect = document.getElementById('charSet'), presetSelect = document.getElementById('colorPresets'), cBot = document.getElementById('colorBottom'), cMid = document.getElementById('colorMid'), cTop = document.getElementById('colorTop'), customInput = document.getElementById('customInput'), customCharGroup = document.getElementById('customCharGroup');
        const camBrightnessInput = document.getElementById('camBrightness');

        const valWidth = document.getElementById('val-width'), valHeight = document.getElementById('val-height'), valFont = document.getElementById('val-font'), valSpeed = document.getElementById('val-speed'), valScale = document.getElementById('val-scale'), valBrightness = document.getElementById('val-brightness');

        let is3D = false, isRainy = false;
        let raindrops = [], smokeParticles = [];

        // 3D 摄像机及特效参数
        let camRot = 0;
        let camOffsetX = 0;
        let camOffsetY = 0;
        let camZoom = 1.0;
        let embersParticles = [];
        let isSliderDragging = false;
        
        let lastMouseX = window.innerWidth / 2;
        let lastMouseY = window.innerHeight / 2;

        // 终极视觉特效变量
        let glitchFrames = 0;
        let globalHue = 0;
        let dustParticles = [];

        const camRotSlider = document.getElementById('camRotSlider');
        const valRot = document.getElementById('val-rot');

        camRotSlider.addEventListener('input', (e) => {
            camRot = e.target.value * Math.PI / 180;
            valRot.value = e.target.value;
            isSliderDragging = true;
        });
        camRotSlider.addEventListener('change', () => { isSliderDragging = false; });

        function syncInput(rangeEl, inputEl, callback) {
            inputEl.value = rangeEl.value;
            rangeEl.oninput = () => { inputEl.value = rangeEl.value; callback(); };
            rangeEl.onchange = () => { rangeEl.value = inputEl.value; callback(); };
        }

        let fontSize = 12, cols, rows, fireData = [], lastTime = 0, speed = 1.0;
        let flameHeight = shapePresets.classic.h, chaosLevel = shapePresets.classic.c, wind = 0;

        const charSets = { 
            ascii: ['@', '#', '$', '*', '!', ';', ':', '.', ' '], 
            binary: ['1', '0', ' '], 
            blocks: ['█', '▓', '▒', '░', ' '], 
            braille: ['⣿', '⣶', '⣤', '⣀', ' '], 
            dots: ['●', '○', '•', '·', ' '], 
            japanese: ['火', '炎', '熱', '炭', ' '], 
            matrix: ['$', 'シ', '1', '0', ' '] 
        };

        document.getElementById('toggle3DSwitch').onchange = function() {
            is3D = this.checked;
            wrapper.classList.toggle('isometric', is3D);
            document.getElementById('group3D').style.display = is3D ? 'flex' : 'none';
        };

        charSetSelect.onchange = function() {
            document.getElementById('customCharGroup').style.display = this.value === 'customChar' ? 'flex' : 'none';
        };

        document.getElementById('toggleRain').onclick = function() {
            isRainy = !isRainy;
            this.innerText = isRainy ? "ON" : "OFF";
        };

        function initDust() {
            dustParticles = [];
            for(let i=0; i<150; i++){
                dustParticles.push({
                    x: (Math.random() - 0.5) * 1200,
                    y: (Math.random() - 0.5) * 1200,
                    z: (Math.random() - 0.2) * 600,
                    speedX: (Math.random() - 0.5) * 0.3,
                    speedY: (Math.random() - 0.5) * 0.3,
                    speedZ: (Math.random() - 0.5) * 0.3
                });
            }
        }

        function initCanvas() {
            fontSize = parseInt(fontSizeInput.value); 
            canvas.width = parseInt(widthInput.value); 
            canvas.height = parseInt(heightInput.value);
            cols = Math.floor(canvas.width / (fontSize * 0.75)); 
            rows = Math.floor(canvas.height / fontSize); 
            fireData = new Array(cols * rows).fill(0);
            initDust();
        }

        function updateUIEffects() {
            if(!is3D) wrapper.style.transform = `scale(${viewScaleInput.value})`;
            speed = parseFloat(speedInput.value);
        }

        presetSelect.onchange = function() { const p = palettes[this.value]; if (p) { cTop.value = p.top; cMid.value = p.mid; cBot.value = p.bot; updateUIEffects(); } };
        const palettes = { classic: { top: "#FF2200", mid: "#FF8800", bot: "#FFFFFF" }, soul: { top: "#0033FF", mid: "#00FFFF", bot: "#EEFFFF" }, forest: { top: "#006622", mid: "#33FF77", bot: "#CCFFDD" }, cyber: { top: "#FF00FF", mid: "#5500FF", bot: "#CCFFFF" }, toxic: { top: "#44FF00", mid: "#FFFF00", bot: "#FFFFFF" }, void: { top: "#333333", mid: "#666666", bot: "#AAAAAA" }, sunset: { top: "#660066", mid: "#FF4400", bot: "#FFCC00" }, ocean: { top: "#000066", mid: "#0044AA", bot: "#FFFFFF" }, gold: { top: "#884400", mid: "#CC9900", bot: "#FFFFAA" }, sakura: { top: "#FF66AA", mid: "#FFBBDD", bot: "#FFFFFF" } };

        function randomizeFireColors() {
            presetSelect.value = "custom"; const h = Math.random() * 360;
            const hslToHex = (h, s, l) => { l /= 100; const a = s * Math.min(l, 1 - l) / 100; const f = n => { const k = (n + h / 30) % 12; const color = l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1); return Math.round(255 * color).toString(16).padStart(2, '0'); }; return `#${f(0)}${f(8)}${f(4)}`; };
            cBot.value = hslToHex(h, 100, 85); cMid.value = hslToHex((h + 20) % 360, 90, 60); cTop.value = hslToHex((h + 40) % 360, 80, 35); updateUIEffects();
        }

        function updateFire() {
            let currentFlameHeight = flameHeight;
            for (let x = 0; x < cols; x++) fireData[(rows - 1) * cols + x] = Math.random() > 0.6 ? 255 : 0;
            for (let y = 0; y < rows - 1; y++) { 
                for (let x = 0; x < cols; x++) { 
                    const idx = y * cols + x, src = ((y + 1) * cols + x); 
                    const drift = Math.round((Math.random() - 0.5) * chaosLevel * 4); 
                    let tx = (x + drift + cols) % cols; 
                    const val = fireData[src] - (Math.random() * currentFlameHeight); 
                    fireData[y * cols + tx] = val > 0 ? val : 0; 
                } 
            }
            if(isRainy) {
                if(Math.random() > 0.6) raindrops.push({x: Math.random()*canvas.width, y: 0, s: 8 + Math.random()*10});
                raindrops.forEach((r, i) => {
                    r.y += r.s;
                    const tx = Math.floor(r.x / (fontSize * 0.75));
                    const ty = Math.floor(r.y / fontSize);
                    const fIdx = ty * cols + tx;
                    if(fireData[fIdx] > 50) {
                        fireData[fIdx] = 0;
                        smokeParticles.push({x: r.x, y: r.y, l: 1.0});
                        raindrops.splice(i, 1);
                    }
                    if(r.y > canvas.height) raindrops.splice(i, 1);
                });
                smokeParticles.forEach((p, i) => { p.y -= 1; p.l -= 0.05; if(p.l <= 0) smokeParticles.splice(i, 1); });
            }
        }

        function draw() {
            ctx.fillStyle = '#000'; ctx.fillRect(0, 0, canvas.width, canvas.height);
            let chars = charSetSelect.value === 'customChar' ? customInput.value.split('') : charSets[charSetSelect.value];
            if (!chars || chars.length === 0) chars = [' '];
            
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 1.3;
            
            const time = Date.now() * 0.002 * speed;
            let globalBrightness = parseFloat(document.getElementById('camBrightness').value);

            // 【特效】色相流转 (CSS Hardware Accelerated Hue Shift)
            if (document.getElementById('toggleHueShift').checked) {
                globalHue = (time * 10) % 360;
                canvas.style.filter = `hue-rotate(${globalHue}deg)`;
            } else {
                canvas.style.filter = 'none';
            }

            // 【特效】偶发数字故障 (Signal Glitch)
            let glitchOffsetX = 0;
            let glitchOffsetY = 0;
            if (document.getElementById('toggleGlitch').checked) {
                if (Math.random() < 0.003 && glitchFrames === 0) {
                    glitchFrames = Math.floor(Math.random() * 5) + 3; // 持续 3-5 帧
                }
            } else {
                glitchFrames = 0;
            }
            if (glitchFrames > 0) {
                glitchFrames--;
                glitchOffsetX = (Math.random() - 0.5) * 40;
                glitchOffsetY = (Math.random() - 0.5) * 20;
            }

            // 恢复纯粹的自动匀速旋转
            if (is3D && document.getElementById('toggleAutoRot').checked) {
                if (!isSliderDragging) {
                    camRot += 0.005 * speed; 
                    let deg = (((camRot * 180 / Math.PI) % 360) + 360) % 360;
                    camRotSlider.value = deg.toFixed(0);
                    valRot.value = deg.toFixed(0);
                }
            }

            let renderQueue = [];
            let side = Math.ceil(Math.sqrt(cols));
            let spacing = (canvas.width * 0.5) / side; 
            let maxDepth = side * spacing;

            const angleIso = Math.PI / 6;
            const project3D = (px, py, pz) => {
                let xr = px * Math.cos(camRot) - py * Math.sin(camRot);
                let yr = px * Math.sin(camRot) + py * Math.cos(camRot);
                let ix = (xr - yr) * Math.cos(angleIso);
                let iy = (xr + yr) * Math.sin(angleIso) - pz;
                return {
                    x: centerX + ix * camZoom + camOffsetX + glitchOffsetX,
                    y: centerY + iy * camZoom + camOffsetY + glitchOffsetY,
                    depthBase: xr + yr
                };
            };

            let peaks = Array.from({length: side}, () => new Array(side).fill(null));

            if (is3D) {
                ctx.save();
                ctx.strokeStyle = 'rgba(100, 150, 255, 0.15)'; 
                ctx.lineWidth = 1;
                
                ctx.beginPath();
                for(let i = 0; i <= side; i++) {
                    let offset = (i - side/2) * spacing;
                    let start = (-side/2) * spacing;
                    let end = (side/2) * spacing;
                    
                    let p1 = project3D(offset, start, 0);
                    let p2 = project3D(offset, end, 0);
                    ctx.moveTo(p1.x, p1.y); ctx.lineTo(p2.x, p2.y);
                    
                    let p3 = project3D(start, offset, 0);
                    let p4 = project3D(end, offset, 0);
                    ctx.moveTo(p3.x, p3.y); ctx.lineTo(p4.x, p4.y);
                }
                ctx.stroke();
                ctx.restore();
            }

            for (let y = 0; y < rows; y++) { 
                for (let x = 0; x < cols; x++) { 
                    const val = fireData[y * cols + x]; 
                    if (val > 15) { 
                        let fillStyle;
                        if (val > 204) fillStyle = cBot.value; 
                        else if (val > 76) fillStyle = cMid.value; 
                        else fillStyle = cTop.value; 
                        
                        let char = chars[chars.length - 1 - Math.floor((val / 255) * (chars.length - 1))];
                        
                        // 故障期间随机改变字符为矩阵乱码
                        if (glitchFrames > 0 && Math.random() < 0.1) {
                            char = ['$', '0', '1', '!', '?', '#'][Math.floor(Math.random()*6)];
                        }
                        
                        if (is3D) {
                            let gridX = x % side;
                            let gridY = Math.floor(x / side);
                            
                            let dx = gridX - side/2 + 0.5;
                            let dy = gridY - side/2 + 0.5;
                            
                            let maxDist = side / 2;
                            let noise = Math.sin(gridX * 0.6 + time * 1.2) * Math.cos(gridY * 0.6 - time * 0.8) * 0.4;
                            let dist = Math.sqrt(dx*dx + dy*dy) + noise * maxDist * 0.6; 
                            
                            let coneFactor = Math.max(0, 1 - (dist / maxDist) * 1.2); 
                            if (coneFactor <= 0) continue;
                            
                            let posX = dx * spacing;
                            let posY = dy * spacing;
                            
                            let posZ = (rows - 1 - y) * (fontSize * 0.8);
                            posZ = posZ * coneFactor; 

                            if (val > 240) posZ *= (1.0 + Math.random() * 0.8);
                            posZ += (val / 255) * (fontSize * 1.5) * coneFactor; 

                            let swayAmplitude = Math.pow(posZ / 50, 1.2) * 2.5; 
                            let swayX = (Math.sin(time + gridY * 0.4 - y * 0.15) * 1.0 + Math.sin(time * 2.3 + gridX * 0.8) * 0.5 + Math.sin(time * 5.1 + gridX * 2.0 + gridY * 2.0) * 0.2) * swayAmplitude;
                            let swayY = (Math.cos(time * 0.9 + gridX * 0.4 - y * 0.12) * 1.0 + Math.cos(time * 2.1 + gridY * 0.7) * 0.5 + Math.cos(time * 4.8 + gridX * 1.5 + gridY * 1.5) * 0.2) * swayAmplitude;
                            
                            posX += swayX; posY += swayY;

                            let p = project3D(posX, posY, posZ);
                            let depthValue = p.depthBase * 10000 + posZ;
                            
                            let alpha = 0.5 + (val / 255) * 0.5;
                            if (document.getElementById('toggleFog').checked) {
                                let fogAlpha = (p.depthBase + maxDepth * 1.5) / (2.5 * maxDepth);
                                fogAlpha = Math.max(0, Math.min(1, fogAlpha));
                                let fogIntensity = val > 200 ? 0.3 : 0.85; 
                                alpha *= (1.0 - fogIntensity + fogIntensity * fogAlpha);
                            }
                            alpha = Math.min(1.0, alpha * globalBrightness);
                            
                            renderQueue.push({ char: char, drawX: p.x, drawY: p.y, color: fillStyle, alpha: alpha, depth: depthValue, isEmber: false });
                            if (!peaks[gridX][gridY] || posZ > peaks[gridX][gridY].posZ) peaks[gridX][gridY] = { drawX: p.x, drawY: p.y, posZ: posZ };

                        } else {
                            let drawX = x * fontSize * 0.75;
                            let drawY = y * fontSize;
                            ctx.globalAlpha = Math.min(1.0, (0.5 + (val / 255) * 0.5) * globalBrightness);
                            ctx.fillStyle = fillStyle;
                            ctx.font = `bold ${fontSize}px 'JetBrains Mono', monospace`;
                            ctx.fillText(char, drawX, drawY);
                        }
                    } 
                } 
            }

            // 【特效】深空浮尘 (Ambient Void Dust)
            if (is3D && document.getElementById('toggleDust').checked) {
                dustParticles.forEach(p => {
                    p.x += p.speedX * speed;
                    p.y += p.speedY * speed;
                    p.z += p.speedZ * speed;
                    // 无缝循环空间
                    if (p.x > 600) p.x = -600; else if (p.x < -600) p.x = 600;
                    if (p.y > 600) p.y = -600; else if (p.y < -600) p.y = 600;
                    if (p.z > 500) p.z = -100; else if (p.z < -100) p.z = 500;

                    let proj = project3D(p.x, p.y, p.z);
                    let alpha = 0.15;
                    if (document.getElementById('toggleFog').checked) {
                        let fogAlpha = (proj.depthBase + maxDepth * 1.5) / (2.5 * maxDepth);
                        fogAlpha = Math.max(0, Math.min(1, fogAlpha));
                        alpha *= (0.15 + 0.85 * fogAlpha);
                    }

                    renderQueue.push({
                        char: '.',
                        drawX: proj.x,
                        drawY: proj.y,
                        color: '#ffffff',
                        alpha: alpha * globalBrightness,
                        depth: proj.depthBase * 10000 + p.z,
                        isEmber: true
                    });
                });
            }

            if (is3D && document.getElementById('toggleEmbers').checked) {
                if (Math.random() < 0.4 * speed) {
                    embersParticles.push({
                        x: (Math.random() - 0.5) * side * 0.5, y: (Math.random() - 0.5) * side * 0.5,
                        z: Math.random() * 20, life: 1.0,
                        char: ['.', '*', '+', '°'][Math.floor(Math.random() * 4)],
                        driftX: (Math.random() - 0.5) * 2, driftY: (Math.random() - 0.5) * 2
                    });
                }
                for (let i = embersParticles.length - 1; i >= 0; i--) {
                    let e = embersParticles[i];
                    e.z += (2 + Math.random() * 2) * speed;
                    e.x += e.driftX * speed + Math.sin(time * 5 + e.z * 0.1) * 0.1;
                    e.y += e.driftY * speed + Math.cos(time * 5 + e.z * 0.1) * 0.1;
                    
                    e.life -= 0.015 * speed;
                    if (e.life <= 0) { embersParticles.splice(i, 1); continue; }

                    let p = project3D(e.x * spacing, e.y * spacing, e.z * (fontSize * 0.8));
                    let alpha = e.life * 0.9;
                    if (document.getElementById('toggleFog').checked) {
                        let fogAlpha = (p.depthBase + maxDepth * 1.5) / (2.5 * maxDepth);
                        fogAlpha = Math.max(0, Math.min(1, fogAlpha));
                        alpha *= (0.15 + 0.85 * fogAlpha);
                    }
                    alpha = Math.min(1.0, alpha * globalBrightness);

                    renderQueue.push({ char: e.char, drawX: p.x, drawY: p.y, color: cTop.value, alpha: alpha, depth: p.depthBase * 10000 + e.z * (fontSize * 0.8), isEmber: true });
                }
            }

            if (is3D) {
                renderQueue.sort((a, b) => a.depth - b.depth);
                
                ctx.globalCompositeOperation = document.getElementById('blendMode').value;
                
                renderQueue.forEach(item => {
                    ctx.globalAlpha = item.alpha;
                    ctx.fillStyle = item.color;
                    ctx.font = item.isEmber ? `bold ${fontSize * 0.6}px 'JetBrains Mono', monospace` : `bold ${fontSize}px 'JetBrains Mono', monospace`;
                    ctx.fillText(item.char, item.drawX, item.drawY);
                });
                
                ctx.globalCompositeOperation = 'source-over'; 

                let style = document.getElementById('contourStyle').value;
                if (style !== 'none') {
                    ctx.lineWidth = 1.0;
                    if (style === 'dashed') ctx.setLineDash([4, 4]);
                    else ctx.setLineDash([]);
                    
                    for (let i = 0; i < side; i++) {
                        for (let j = 0; j < side; j++) {
                            let current = peaks[i][j];
                            if (!current) continue;

                            if (i + 1 < side && peaks[i+1][j]) {
                                let right = peaks[i+1][j];
                                let avgZ = (current.posZ + right.posZ) / 2;
                                let alpha = Math.max(0, Math.min(1.0, (avgZ - 20) / 80)) * 0.7;
                                alpha = Math.min(1.0, alpha * globalBrightness);
                                if (alpha > 0.05) {
                                    ctx.globalAlpha = alpha; ctx.strokeStyle = cMid.value; 
                                    ctx.beginPath(); ctx.moveTo(current.drawX, current.drawY); ctx.lineTo(right.drawX, right.drawY); ctx.stroke();
                                }
                            }
                            if ((style === 'solid' || style === 'dashed') && j + 1 < side && peaks[i][j+1]) {
                                let bottom = peaks[i][j+1];
                                let avgZ = (current.posZ + bottom.posZ) / 2;
                                let alpha = Math.max(0, Math.min(1.0, (avgZ - 20) / 80)) * 0.7;
                                alpha = Math.min(1.0, alpha * globalBrightness);
                                if (alpha > 0.05) {
                                    ctx.globalAlpha = alpha; ctx.strokeStyle = cMid.value;
                                    ctx.beginPath(); ctx.moveTo(current.drawX, current.drawY); ctx.lineTo(bottom.drawX, bottom.drawY); ctx.stroke();
                                }
                            }
                        }
                    }
                    ctx.setLineDash([]);
                }
                ctx.globalAlpha = 1.0;

                // 【特效】光学色差分离 (RGB Split)
                if (document.getElementById('toggleRGBSplit').checked) {
                    let splitOffset = glitchFrames > 0 ? (Math.random() * 12 + 4) : 1.5;
                    ctx.save();
                    ctx.globalCompositeOperation = 'screen';
                    ctx.globalAlpha = 0.35;
                    ctx.drawImage(canvas, splitOffset, 0);
                    ctx.drawImage(canvas, -splitOffset, 0);
                    ctx.restore();
                }
            }

            if(isRainy) {
                ctx.fillStyle = "rgba(180, 200, 255, 0.5)";
                raindrops.forEach(r => ctx.fillRect(r.x, r.y, 1, 6));
                ctx.fillStyle = "#888";
                const smokeChars = ['~', '&', '§'];
                smokeParticles.forEach(p => { ctx.globalAlpha = p.l; ctx.font = `bold ${fontSize}px 'JetBrains Mono', monospace`; ctx.fillText(smokeChars[Math.floor(Math.random()*3)], p.x, p.y); });
                ctx.globalAlpha = 1.0;
            }
            
            // 视网膜 CRT 后期滤镜
            if (document.getElementById('toggleCRT').checked) {
                ctx.save();
                ctx.fillStyle = 'rgba(0, 0, 0, 0.15)';
                for (let i = 0; i < canvas.height; i += 2) {
                    ctx.fillRect(0, i, canvas.width, 1);
                }
                let gradient = ctx.createRadialGradient(
                    canvas.width / 2, canvas.height / 2, 0,
                    canvas.width / 2, canvas.height / 2, Math.max(canvas.width, canvas.height) / 1.2
                );
                gradient.addColorStop(0, 'rgba(0,0,0,0)');
                gradient.addColorStop(1, 'rgba(0,0,0,0.7)');
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.restore();
            }
        }

        let isRightDragging = false;
        
        canvas.addEventListener('contextmenu', e => e.preventDefault());
        
        canvas.addEventListener('mousedown', e => {
            if (e.button === 2 && is3D) {
                isRightDragging = true;
                lastMouseX = e.clientX;
                lastMouseY = e.clientY;
            }
        });

        window.addEventListener('mouseup', e => {
            if (e.button === 2) isRightDragging = false;
        });

        canvas.addEventListener('wheel', e => {
            if (is3D) {
                e.preventDefault();
                camZoom -= e.deltaY * 0.001;
                camZoom = Math.max(0.2, Math.min(camZoom, 5.0));
            }
        }, {passive: false});

        function handleInput(e) {
            // 彻底关闭 3D 模式下的点火互动，保证纯粹观赏性
            if (is3D) return; 

            const rect = canvas.getBoundingClientRect();
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            
            let x = Math.floor(((clientX - rect.left) / rect.width * canvas.width) / (fontSize * 0.75));
            let y = Math.floor(((clientY - rect.top) / rect.height * canvas.height) / fontSize);
            for(let i=-2; i<=2; i++){ 
                for(let j=-2; j<=2; j++){ 
                    const idx = (y+j) * cols + (x+i); 
                    if(fireData[idx] !== undefined) fireData[idx] = 255; 
                } 
            }
        }

        canvas.addEventListener('mousemove', e => {
            if (isRightDragging && is3D) {
                let dx = e.clientX - lastMouseX;
                let dy = e.clientY - lastMouseY;
                camRot += dx * 0.01;
                camOffsetY += dy;
                camOffsetX += dx * 0.5; 
            } else if (e.buttons === 1 && !is3D) { 
                handleInput(e); // 仅在 2D 模式下保留交互
            }
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
        });
        
        canvas.addEventListener('touchstart', (e) => { if(!is3D) handleInput(e); }, {passive:false});
        canvas.addEventListener('touchmove', (e) => { if(!is3D) { e.preventDefault(); handleInput(e); } }, {passive:false});

        window.onload = () => {
            syncInput(widthInput, valWidth, initCanvas); syncInput(heightInput, valHeight, initCanvas); syncInput(fontSizeInput, valFont, initCanvas);
            syncInput(speedInput, valSpeed, updateUIEffects); syncInput(viewScaleInput, valScale, updateUIEffects);
            syncInput(camBrightnessInput, valBrightness, () => {}); 
            
            initCanvas(); updateUIEffects(); 
            function loop(timestamp) { if (timestamp - lastTime > 1000 / (30 * speed)) { updateFire(); draw(); lastTime = timestamp; } requestAnimationFrame(loop); }
            requestAnimationFrame(loop);
        };
    </script>
</body>
</html>